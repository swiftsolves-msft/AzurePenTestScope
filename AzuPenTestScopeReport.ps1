# Created On: 8/25/2018 3:21 AM
# Created By: Nathan Swift nate.swift@live.com
# This script is as is and not supported by Microsoft 
# Microsoft does not assume any risk of data loss
# Use it at your own risk
################################################################################

<# 
Current Services:

PaaS SQL DB
PaaS MySQL DB
PaaS PostgreSQL DB
Cosmos DB
Functions
Storage Account
TrafficManager
KeyVault
AzureDataLakeStore
AzureDataLakeAnalytics
Redis Cache
App Service
App Service Enviroment
Service Fabric - InProgress
Batch
ServiceBus
EventHubs
IOT Hub
API Management
Automation
Public IP
Search
Analysis Services
Logic App
CDN
HDInsights
ACI
ACR


#>

<#  Possible Futures:
 
 1. Expand more services with endpoints to scope, like AKS and ServiceFabric.
 2. Expand URLs on AppServices
 3. Add column in report for Admin username
 4. Use crowbar or some utility to brute force 3389 pip to test for weak user\pass - ARM deploy SF,Batch,Automation, or ACI
 5. Other PenTesting Automation ?
 6. Write Out How to update script for services

 #>
param(
  ## Optional, if not provided will use all subscriptions
  [string]$SubscriptionId,
  [string]$OutputDirectory = "C:\Temp",
  [boolean]$PreservePriorOutput = $true
)

#create temp dir
New-Item -ItemType Directory -Force -Path $OutputDirectory

# Path and filename for output data file being generated.
$scopepath = -join ($OutputDirectory, "\scope.txt")
$outputpath = -join ($OutputDirectory, "\output.csv")

# Time Tracking Start
$datetimestart = Get-Date
Write-Host $scopepath

#Check if a scope file already exists
$scopeFileExists = Test-Path -Path $scopepath

if ($scopeFileExists) {
    if ($PreservePriorOutput) {
        Rename-Item -Path $scopepath -NewName ("scope." + $datetimestart.ToFileTime().ToString() + ".txt")
        Write-host "Renamed Previous Scope File"    
    }
    else {
        Remove-Item -Path $scopepath
        Write-host "Removed Previous Scope File"    
    }
}

#Check if an ouput file already exists
$outputFileExists = Test-Path -Path $outputpath

if ($outputFileExists) {
    if ($PreservePriorOutput) {
        Rename-Item -Path $outputpath -NewName ("output." + $datetimestart.ToFileTime().ToString() + ".csv")
        Write-host "Renamed Previous Output File"    
    }
    else {
        Remove-Item -Path $outputpath
        Write-host "Removed Previous Output File"    
    }
}



# Authenticate Piece
# There are many ways to authenticate in a non interactive and automated fashion, please adapt your needs accordingly. 
Login-AzureRmAccount

# Collect all subscriptions
$subs = Get-AzureRmSubscription | Where-Object { $SubscriptionId -eq $null -or $_.SubscriptionId -eq $SubscriptionId }

# Outputfile for azure inventory
$outputFile = $scopepath

#Set and apply 1st line of csv headers
$scopestring = "Subscription,ResourceGroupName,Type,ResourceName,URLs"
$scopestring | Out-File $outputFile -append -force

# Iterate through all subscriptions
foreach ($sub in $subs) {

    # Set the current  Azure Subscription to pull information from
    Set-AzureRmContext -Subscription $sub.Name


    #Collect all VMs in current context Subscription
    $Resources = Get-AzureRmResource -ExpandProperties

    # Loop and iterate through all VMs to begin collecting data
    foreach ($Resource in $Resources) {

        # Type of Azure resource
        $Type = $Resource.resourcetype

        # Set variable $URL to NOTSET to prevent azure services that do not contain public enpoint from being written into scope report.
        $URL = "NOTSET"

        #storage accounts are weird, so we have to wire the output up differently
        If ($Type -eq "Microsoft.Storage/storageAccounts") {
            # "Subscription,ResourceGroupName,Type,ResourceName,URLs"
            $URL = $Resource.Name + ".blob.core.windows.net"
            $scopestring = "$($sub.Name),$($Resource.ResourceGroupName),$($Type),$($Resource.name),$($URL)"
            $scopestring | Out-File $outputFile -append -force

            $URL = $Resource.Name + ".file.core.windows.net"
            $scopestring = "$($sub.Name),$($Resource.ResourceGroupName),$($Type),$($Resource.name),$($URL)"
            $scopestring | Out-File $outputFile -append -force

            $URL = $Resource.Name + ".queue.core.windows.net"
            $scopestring = "$($sub.Name),$($Resource.ResourceGroupName),$($Type),$($Resource.name),$($URL)"
            $scopestring | Out-File $outputFile -append -force

            $URL = $Resource.Name + ".table.core.windows.net"
            $scopestring = "$($sub.Name),$($Resource.ResourceGroupName),$($Type),$($Resource.name),$($URL)"
            $scopestring | Out-File $outputFile -append -force
        }

        ## catching for $URL on single service URLs
        # RESEARCH https://docs.microsoft.com/en-us/azure/sql-database/sql-database-connectivity-architecture
        ##SQL
        ElseIf ($Type -eq "Microsoft.Sql/servers") {
            $URL = $Resource.Properties.fullyQualifiedDomainName
        }
        ##PostgreSQL
        ElseIf ($Type -eq "Microsoft.DBforPostgreSQL/servers") {
            $URL = $Resource.Properties.fullyQualifiedDomainName
        }
        ##MySQL
        ElseIf ($Type -eq "Microsoft.DBforMySQL/servers") {
            $URL = $Resource.Properties.fullyQualifiedDomainName
        }
        ##ACR
        ElseIf ($Type -eq "Microsoft.ContainerRegistry/registries") {
            $URL = $Resource.Properties.loginServer
        }
        ##ACI
        ElseIf ($Type -eq "Microsoft.ContainerInstance/containerGroups") {
            $URL = $Resource.Properties.ipAddress.ip
            If ($Resource.Properties.ipAddress.fqdn -cmatch "azurecontainer.io" ) {
                $URL = $Resource.Properties.ipAddress.fqdn
            }
        }
        ##Functions
        ElseIf ($Type -eq "Microsoft.Web/sites/functions") {
            $URL = $Resource.Properties.hostNames
        }
        ##CosmosDB
        # "Subscription,ResourceGroupName,Type,ResourceName,URLs"
        ElseIf ($Type -eq "Microsoft.DocumentDB/databaseAccounts") {
            $URL = $Resource.Properties.documentEndpoint
            $scopestring = "$($sub.Name),$($Resource.ResourceGroupName),$($Type),$($Resource.name),$($URL)"
            $scopestring | Out-File $outputFile -append -force

            $URL = $Resource.Properties.tableEndpoint
            If (!$URL) {
                #Write-Host = "TableEndpoint not found"  -ForegroundColor DarkGreen
            }
            Else {
                $scopestring = "$($sub.Name),$($Resource.ResourceGroupName),$($Type),$($Resource.name),$($URL)"
                $scopestring | Out-File $outputFile -append -force
            }

            $URL = $Resource.Properties.gremlinEndpoint            
            If (!$URL) {
                #Write-Host = "GremlinEndpoint not found" -ForegroundColor DarkGreen
            }
            Else {
                $scopestring = "$($sub.Name),$($Resource.ResourceGroupName),$($Type),$($Resource.name),$($URL)"
                $scopestring | Out-File $outputFile -append -force
            }
        }
        #TRAFFICMANAGER
        ElseIf ($Type -eq "Microsoft.Network/trafficmanagerprofiles") {
            $URL = $Resource.Name + ".trafficmanager.net"
        }
        ##KEYVAULT
        ElseIf ($Type -eq "Microsoft.KeyVault/vaults") {
            $URL = $Resource.Properties.vaultUri
        }
        ##DATALAKE
        ElseIf ($Type -eq "Microsoft.DataLakeStore/accounts") {
            $URL = $Resource.Properties.endpoint
        }
        ##DATALAKESTORE
        ElseIf ($Type -eq "Microsoft.DataLakeAnalytics/accounts/DataLakeStoreAccounts") {
            $URL = $Resource.Properties.endpoint
        }
        ##REDIS
        ElseIf ($Type -eq "Microsoft.Cache/Redis") {

            #format URL based on redis setting
            If ($Resource.Properties.EnableNonSslPort -eq $true ) {
                $URL = $Resource.Properties.hostName + ":" + $Resource.Properties.port
            }
            Else {
                $URL = $Resource.Properties.hostName + ":" + $Resource.Properties.sslport
            }
        }
        ##WEBSITES & APPSERVICEENVIROMENT
        ElseIf ($Type -eq "Microsoft.Web/sites") {
            $URL = $Resource.Properties.hostNames
        }
        ##SERVICEFABRIC 
        ##Multipls URLs and Ports rewrite logic
        #ElseIf ($Type -eq "Microsoft.ServiceFabric/clusters") {
        #    $URL = $Resource.Properties.clusterEndpoint
        #}
        ##BATCH
        ElseIf ($Type -eq "Microsoft.Batch/batchAccounts") {
            $loc = $Resource.Location
            $URL = $Resource.Properties.accountEndpoint
        }

        ##??
        ## Investigate further their is a swagger def file, maybe some other url service endpoint ?
        ## https://{location}.services.azureml.net/subscriptions/{subscriptionguid}/services/{id}/swagger.json
        #ElseIf ($Type -eq "Microsoft.MachineLearning/webServices") {

        #$URL = $Resource.Name + ".services.azureml.net"
        #}

        ##EVENTHUB
        ElseIf ($Type -eq "Microsoft.ServiceBus/namespaces" -or $Type -eq "Microsoft.EventHub/namespaces") {
            $URL = $Resource.Properties.serviceBusEndpoint
        }
        ##IOTHUB
        ElseIf ($Type -eq "Microsoft.Devices/IotHubs") {
            $URL = $Resource.Properties.hostName
        }
        ##APIM
        # "Subscription,ResourceGroupName,Type,ResourceName,URLs"
        ElseIf ($Type -eq "Microsoft.ApiManagement/service") {
            $URL = $Resource.Properties.gatewayUrl
            $scopestring = "$($sub.Name),$($Resource.ResourceGroupName),$($Type),$($Resource.name),$($URL)"
            $scopestring | Out-File $outputFile -append -force

            $URL = $Resource.Properties.gatewayRegionalUrl
            $scopestring = "$($sub.Name),$($Resource.ResourceGroupName),$($Type),$($Resource.name),$($URL)"
            $scopestring | Out-File $outputFile -append -force

            $URL = $Resource.Properties.portalUrl
            $scopestring = "$($sub.Name),$($Resource.ResourceGroupName),$($Type),$($Resource.name),$($URL)"
            $scopestring | Out-File $outputFile -append -force

            $URL = $Resource.Properties.managementApiUrl
            $scopestring = "$($sub.Name),$($Resource.ResourceGroupName),$($Type),$($Resource.name),$($URL)"
            $scopestring | Out-File $outputFile -append -force
        }
        ##AUTOMATION
        ElseIf ($Type -eq "Microsoft.Automation/automationAccounts") {
            $URL = $Resource.Properties.RegistrationUrl
        }
        ##IPADDRESS
        ElseIf ($Type -eq "Microsoft.Network/publicIPAddresses") {
            
            $URL = $Resource.Properties.ipAddress
            If ($Resource.Properties.dnsSettings.Fqdn -cmatch "cloudapp.azure.com" ) {
                $URL = $Resource.Properties.dnsSettings.Fqdn
            }

            # If no IP address or no DNS name found, then IP is dynamic and deallocated setting to not report
            If (!$URL) {
                $URL = "NOTSET"
            }
        }
        ##SEARCH
        ElseIf ($Type -eq "Microsoft.Search/searchServices") {
            $URL = $Resource.Name + ".search.windows.net"
        }
        ##ANALYSIS SERVICES
        ElseIf ($Type -eq "Microsoft.AnalysisServices/servers") {
            $URL = $Resource.Properties.serverFullName
        }
        ##INTEGRATION
        ElseIf ($Type -eq "Microsoft.Logic/integrationAccounts") {
            $URL = $Resource.Properties.accessEndpoint
        }
        ##CDN
        ElseIf ($Type -eq "Microsoft.Cdn/profiles/endpoints") {
            $URL = $Resource.Properties.hostName
        }
        ##HDINSIGHT
        # "Subscription,ResourceGroupName,Type,ResourceName,URLs"
        ElseIf ($Type -eq "Microsoft.HDInsight/clusters") {
            $URL = $Resource.Properties.connectivityEndpoints.location[0]+ ":" + $Resource.Properties.connectivityEndpoints.port[0]
            $scopestring = "$($sub.Name),$($Resource.ResourceGroupName),$($Type),$($Resource.name),$($URL)"
            $scopestring | Out-File $outputFile -append -force

            $URL = $Resource.Properties.connectivityEndpoints.location[1]+ ":" + $Resource.Properties.connectivityEndpoints.port[1]
            $scopestring = "$($sub.Name),$($Resource.ResourceGroupName),$($Type),$($Resource.name),$($URL)"
            $scopestring | Out-File $outputFile -append -force
        }

        ## writing for $URL on single service URLs
        If ($Type -eq "Microsoft.Storage/storageAccounts" -or $Type -eq "Microsoft.ApiManagement/service" -or $Type -eq "Microsoft.DocumentDB/databaseAccounts" -or $Type -eq "Microsoft.HDInsight/clusters" -or $URL -eq "NOTSET") {
            #Write-host "Finished in above logic due to multiple URLs to service"
        }
        Else {
            # "Subscription,ResourceGroupName,Type,ResourceName,URLs"
            # Write out Scope line of data collected and place into csv
            $scopestring = "$($sub.Name),$($Resource.ResourceGroupName),$($Type),$($Resource.name),$($URL)"
            $scopestring | Out-File $outputFile -append -force

        }
    } #foreach($Resource in $Resources) 
} #foreach($sub in $subs)

# Time Tracking Finished
$datetimeend = Get-Date
Write-Host $datetimestart
Write-Host $datetimeend

# Once done import the data into excel
$CSV = Import-Csv -Path $scopepath
$CSV | Export-Csv -Path $outputpath -NoTypeInformation