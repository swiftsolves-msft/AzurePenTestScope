# Created On: 8/25/2018 3:21 AM
# Created By: Nathan Swift nate.swift@live.com
# This script is as is and not supported by Microsoft 
# Microsoft does not assume any risk of data loss
# Use it at your own risk
################################################################################

<# 
Current Services:

PaaS SQL DB
PaaS MySQL DB
Cosmos DB
Functions
Storage Account
TrafficManager
KeyVault
AzureDataLakeStore
AzureDataLakeAnalytics
Redis Cache
App Service
Batch
ServiceBus
EventHubs
IOT Hub
API Management
Automation
Public IP
Search
Analysis Services
Logic App
CDN
HDInsights
ACI
ACR


#>

<#  Possible Futures:
 
 1. Expand more services with endpoints to scope, like AKS.
 2. Report on NSGs port applied \ ACLs applies
 3. Use crowbar or some utility to brute force 3389 pip to test for weak user\pass
 4. Other PenTesting Automation ?
 5. Write Out How to update script for services

 #>
param(
    [string]$OutputDirectory = "C:\Temp",
    [boolean]$PreservePriorOutput = $true
)

#create temp dir
New-Item -ItemType Directory -Force -Path $OutputDirectory

# Path and filename for output data file being generated.
$scopepath = -join ($OutputDirectory, "\scope.txt")
$outputpath = -join ($OutputDirectory, "\output.csv")

# Time Tracking Start
$datetimestart = Get-Date
Write-Host $scopepath

#Check if a scope file already exists
$scopeFileExists = Test-Path -Path $scopepath

if ($scopeFileExists)
{
    if($PreservePriorOutput)
    {
        Rename-Item -Path $scopepath -NewName ("scope." + $datetimestart.ToFileTime().ToString() + ".txt")
        Write-host "Renamed Previous Scope File"    
    }
    else 
    {
        Remove-Item -Path $scopepath
        Write-host "Removed Previous Scope File"    
    }
}

#Check if an ouput file already exists
$outputFileExists = Test-Path -Path $outputpath

if ($outputFileExists)
{
    if($PreservePriorOutput)
    {
        Rename-Item -Path $outputpath -NewName ("output." + $datetimestart.ToFileTime().ToString() + ".csv")
        Write-host "Renamed Previous Output File"    
    }
    else 
    {
        Remove-Item -Path $outputpath
        Write-host "Removed Previous Output File"    
    }
}



# Authenticate Piece
# There are many ways to authenticate in a non interactive and automated fashion, please adapt your needs accordingly. 
Login-AzureRmAccount


# Collect all subscriptions
$subs = Get-AzureRmSubscription

# Outputfile for azure inventory
$outputFile = $scopepath

#Set and apply 1st line of csv headers
$scopestring = "Subscription,ResourceGroupName,Type,ResourceName,URLs"
$scopestring | Out-File $outputFile -append -force

# Iterate through all subscriptions
foreach($sub in $subs) 
{

    # Set the current  Azure Subscription to pull information from
    Set-AzureRmContext -Subscription $sub.Name


    #Collect all VMs in current context Subscription
    $Resources = Get-AzureRmResource

    # Loop and iterate through all VMs to begin collecting data
    foreach($Resource in $Resources) 
    {

        # Type of Azure resource
        $Type = $Resource.resourcetype

        # Set variable $URL to NOTSET to prevent azure services that do not contain public enpoint from being written into scope report.
        $URL = "NOTSET"

        #storage accounts are weird, so we have to wire the output up differently
        If ($Type -eq "Microsoft.Storage/storageAccounts")
        {
            # "Subscription,ResourceGroupName,Type,ResourceName,URLs"
            $URL = $Resource.Name + ".blob.core.windows.net"
            $scopestring = "$($sub.Name),$($Resource.ResourceGroupName),$($Type),$($Resource.name),$($URL)"
            $scopestring | Out-File $outputFile -append -force

            $URL = $Resource.Name + ".file.core.windows.net"
            $scopestring = "$($sub.Name),$($Resource.ResourceGroupName),$($Type),$($Resource.name),$($URL)"
            $scopestring | Out-File $outputFile -append -force

            $URL = $Resource.Name + ".queue.core.windows.net"
            $scopestring = "$($sub.Name),$($Resource.ResourceGroupName),$($Type),$($Resource.name),$($URL)"
            $scopestring | Out-File $outputFile -append -force

            $URL = $Resource.Name + ".table.core.windows.net"
            $scopestring = "$($sub.Name),$($Resource.ResourceGroupName),$($Type),$($Resource.name),$($URL)"
            $scopestring | Out-File $outputFile -append -force
        }

        ## catching for $URL on single service URLs
        # RESEARCH https://docs.microsoft.com/en-us/azure/sql-database/sql-database-connectivity-architecture
        ##SQL
        ElseIf ($Type -eq "Microsoft.Sql/servers") 
        {
            $URL = $Resource.Name + ".database.windows.net"
        }
        ##MySQL
        ElseIf ($Type -eq "Microsoft.DBforMySQL/servers") 
        {
            $URL = $Resource.Name + ".mysql.database.azure.com"
        }
        ##ACR
        ElseIf ($Type -eq "Microsoft.ContainerRegistry/registries") 
        {
            $URL = $Resource.Name + ".azurecr.io"
        }
        ##ACI
        ElseIf ($Type -eq "Microsoft.ContainerInstance/containerGroups") 
        {
            $PIP = Get-AzureRmContainerGroup -ResourceGroupName $Resource.ResourceGroupName -Name $Resource.Name
            $URL = $PIP.IpAddress
            If ($PIP.Fqdn -cmatch "azurecontainer.io" ) 
            {
                $URL = $PIP.Fqdn
            }
        }
        ##Functions
        ElseIf ($Type -eq "Microsoft.Web/sites/functions") 
        {
            $URL = $Resource.Name + ".azurewebsites.net"
        }
        ##CosmosDB
        ElseIf ($Type -eq "Microsoft.DocumentDB/databaseAccounts") 
        {
            $URL = $Resource.Name + "documents.azure.com"
        }
        #TRAFFICMANAGER
        ElseIf ($Type -eq "Microsoft.Network/trafficmanagerprofiles") 
        {
        $URL = $Resource.Name + ".trafficmanager.net"
        }
        ##KEYVAULT
        ElseIf ($Type -eq "Microsoft.KeyVault/vaults") 
        {
            $URL = $Resource.Name + ".vault.azure.net"
        }
        ##DATALAKE
        ElseIf ($Type -eq "Microsoft.DataLakeStore/accounts") 
        {
            $URL = $Resource.Name + ".azuredatalakestore.net"
        }
        ##DATALAKESTORE
        ElseIf ($Type -eq "Microsoft.DataLakeAnalytics/accounts/DataLakeStoreAccounts") 
        {
            $URL = $Resource.Name + ".azuredatalakestore.net"
        }
        ##REDIS
        ElseIf ($Type -eq "Microsoft.Cache/Redis") 
        {
            $redis = Get-AzureRmRedisCache -ResourceGroupName $Resource.ResourceGroupName -Name $Resource.Name

            #format URL based on redis setting
            If ($redis.EnableNonSslPort -eq $true ) 
            {
                $URL = $Resource.Name + ".redis.cache.windows.net:" + $redis.Port
            }
            Else 
            {
                $URL = $Resource.Name + ".redis.cache.windows.net:6379"  + $redis.SslPort
            }
        }
        ##WEBSITES
        ElseIf ($Type -eq "Microsoft.Web/sites") 
        {
            $URL = $Resource.Name + ".azurewebsites.net"
        }
        ##BATCH
        ElseIf ($Type -eq "Microsoft.Batch/batchAccounts") 
        {
            $loc = $Resource.Location
            $URL = $Resource.Name + "." + $loc + ".batch.azure.com"
        }

        ##??
        ## Investigate further their is a swagger def file, maybe some other url service endpoint ?
        ## https://{location}.services.azureml.net/subscriptions/{subscriptionguid}/services/{id}/swagger.json
        #ElseIf ($Type -eq "Microsoft.MachineLearning/webServices") {

        #$URL = $Resource.Name + ".services.azureml.net"
        #}

        ##EVENTHUB
        ElseIf ($Type -eq "Microsoft.ServiceBus/namespaces" -or $Type -eq "Microsoft.EventHub/namespaces") 
        {
            $URL = $Resource.Name + ".servicebus.windows.net"
        }
        ##IOTHUB
        ElseIf ($Type -eq "Microsoft.Devices/IotHubs") 
        {
            $URL = $Resource.Name + ".azure-devices.net"
        }
        ##APIM
        # Possibly include the developer portal as a multi service url ?
        ElseIf ($Type -eq "Microsoft.ApiManagement/service") 
        {
            $URL = $Resource.Name + ".azure-api.net"
        }
        ##AUTOMATION
        ElseIf ($Type -eq "Microsoft.Automation/automationAccounts") 
        {
            $URL = (Get-AzureRmAutomationRegistrationInfo -ResourceGroupName $Resource.ResourceGroupName -AutomationAccountName $Resource.Name).Endpoint
        }
        ##IPADDRESS
        ElseIf ($Type -eq "Microsoft.Network/publicIPAddresses") 
        {
            $PIP = Get-AzureRmPublicIpAddress -ResourceGroupName $Resource.ResourceGroupName -Name $Resource.Name
            $URL = $PIP.IpAddress

            If ($PIP.DnsSettings.Fqdn -cmatch "cloudapp.azure.com" ) 
            {
                $URL = $PIP.DnsSettings.Fqdn
            }
        }
        ##SEARCH
        ElseIf ($Type -eq "Microsoft.Search/searchServices") 
        {
            $URL = $Resource.Name + ".search.windows.net"
        }
        ##ANALYSIS SERVICES
        ElseIf ($Type -eq "Microsoft.AnalysisServices/servers") 
        {
            $URL = (Get-AzureRmAnalysisServicesServer -ResourceGroupName $Resource.ResourceGroupName -Name $Resource.Name).ServerFullName
        }
        ##INTEGRATION
        ElseIf ($Type -eq "Microsoft.Logic/integrationAccounts") 
        {
            $loc = $Resource.Location
            $URL = $Resource.Name + "." + $loc + ".logic.azure.com"
        }
        ##CDN
        ElseIf ($Type -eq "Microsoft.Cdn/profiles/endpoints") 
        {
            $URL = $Resource.Name + ".azureedge.net"
        }
        ##HDINSIGHT
        ElseIf ($Type -eq "Microsoft.HDInsight/clusters") 
        {
            $URL = $Resource.Name + ".azurehdinsight.net"
        }

        ## writing for $URL on single service URLs
        If ($Type -eq "Microsoft.Storage/storageAccounts" -or $URL -eq "NOTSET")
        {
            #Write-host "Finished in above logic due to multiple URLs to service"
        }
        Else 
        {
            # "Subscription,ResourceGroupName,Type,ResourceName,URLs"
            # Write out Scope line of data collected and place into csv
            $scopestring = "$($sub.Name),$($Resource.ResourceGroupName),$($Type),$($Resource.name),$($URL)"
            $scopestring | Out-File $outputFile -append -force

        }
    } #foreach($Resource in $Resources) 
} #foreach($sub in $subs)

# Time Tracking Finished
$datetimeend = Get-Date
Write-Host $datetimestart
Write-Host $datetimeend

# Once done import the data into excel
$CSV = Import-Csv -Path $scopepath
$CSV | Export-Csv -Path $csvpath -NoTypeInformation