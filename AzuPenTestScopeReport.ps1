# Created On: 8/25/2018 3:21 AM
# Created By: Nathan Swift nate.swift@live.com
# Updated By: Roberto Mardeni roberto.mardeni@microsoft.com
# This script is as is and not supported by Microsoft 
# Microsoft does not assume any risk of data loss
# Use it at your own risk
################################################################################

<# 
Current Services:

PaaS SQL DB
PaaS MySQL DB
PaaS PostgreSQL DB
Cosmos DB
Functions
Storage Account
TrafficManager
KeyVault
AzureDataLakeStore
AzureDataLakeAnalytics
Redis Cache
App Service
App Service Enviroment
Service Fabric - InProgress
Batch
ServiceBus
EventHubs
IOT Hub
API Management
Automation
Public IP
Search
Analysis Services
Logic App
CDN
HDInsights
ACI
ACR
#>

<#  Possible Futures:
 
 1. Expand more services with endpoints to scope, like AKS and ServiceFabric.
 2. Expand URLs on AppServices
 3. Add column in report for Admin username
 4. Use crowbar or some utility to brute force 3389 pip to test for weak user\pass - ARM deploy SF,Batch,Automation, or ACI
 5. Other PenTesting Automation ?
 6. Write Out How to update script for services

 #>
param(
  ## Optional, if not provided will use all subscriptions
  [string]$SubscriptionId,
  [string]$OutputDirectory = "C:\Temp",
  [boolean]$PreservePriorOutput = $true
)

$ErrorActionPreference = "Stop"

#create temp dir
New-Item -ItemType Directory -Force -Path $OutputDirectory | Out-Null

# Path and filename for output data file being generated.
$scopepath = -join ($OutputDirectory, "\scope.txt")
$outputpath = -join ($OutputDirectory, "\output.csv")

# Time Tracking Start
$datetimestart = Get-Date
Write-Host $scopepath

#Check if a scope file already exists
$scopeFileExists = Test-Path -Path $scopepath

if ($scopeFileExists) {
  if ($PreservePriorOutput) {
    Rename-Item -Path $scopepath -NewName ("scope." + $datetimestart.ToFileTime().ToString() + ".txt")
    Write-host "Renamed Previous Scope File"    
  }
  else {
    Remove-Item -Path $scopepath
    Write-host "Removed Previous Scope File"    
  }
}

#Check if an ouput file already exists
$outputFileExists = Test-Path -Path $outputpath

if ($outputFileExists) {
  if ($PreservePriorOutput) {
    Rename-Item -Path $outputpath -NewName ("output." + $datetimestart.ToFileTime().ToString() + ".csv")
    Write-host "Renamed Previous Output File"    
  }
  else {
    Remove-Item -Path $outputpath
    Write-host "Removed Previous Output File"    
  }
}

# Authenticate Piece
# There are many ways to authenticate in a non interactive and automated fashion, please adapt your needs accordingly. 
Login-AzureRmAccount

# Collect all subscriptions
$subs = Get-AzureRmSubscription | Where-Object { $SubscriptionId -eq $null -or $_.SubscriptionId -eq $SubscriptionId }

# Outputfile for azure inventory
$outputFile = $scopepath

#Set and apply 1st line of csv headers
$scopestring = "Subscription,ResourceGroupName,Type,ResourceName,URLs"
$scopestring | Out-File $outputFile -append -force

# Iterate through all subscriptions
foreach ($sub in $subs) {

  # Set the current  Azure Subscription to pull information from
  Set-AzureRmContext -Subscription $sub.Name | Out-Null

  #Collect all resources in current context Subscription
  $Resources = Get-AzureRmResource -ExpandProperties

  # Loop and iterate through all VMs to begin collecting data
  foreach ($Resource in $Resources) {

    # Type of Azure resource
    $RGName = $Resource.ResourceGroupName
    $Name = $Resource.name
    $Type = $Resource.resourcetype

    # Set variable $URL to NOTSET to prevent azure services that do not contain public enpoint from being written into scope report.
    $URL = "NOTSET"

    ## Utility function to write the scope out
    function Write-Scope {
      param ([string]$URL)
      if ($URL) {
        $scopestring = "$($sub.Name),$RGName,$Type,$Name,$URL"
        $scopestring | Out-File $outputFile -append -force
      }
    }

    try {
        
      switch -Regex ($Type) {
        ## Storage Accounts
        "Microsoft.Storage/storageAccounts$" {
          #storage accounts are weird, so we have to wire the output up differently
          "blob", "file", "queue", "table" | ForEach-Object {
            Write-Scope "$Name.$_.core.windows.net"
          }; break
        }
        ## SQL
        "Microsoft.Sql/servers$" { Write-Scope $Resource.Properties.fullyQualifiedDomainName; break }
        ## PostgreSQL
        "Microsoft.DBforPostgreSQL/servers$" { Write-Scope $Resource.Properties.fullyQualifiedDomainName; break }
        ## MySQL
        "Microsoft.DBforMySQL/servers$" { Write-Scope $Resource.Properties.fullyQualifiedDomainName; break }
        ## ACR
        "Microsoft.ContainerRegistry/registries$" { Write-Scope $Resource.Properties.loginServer; break }
        ## ACI
        "Microsoft.ContainerInstance/containerGroups$" { 
          $URL = $Resource.Properties.ipAddress.ip
          If ($Resource.Properties.ipAddress.fqdn -cmatch "azurecontainer.io" ) {
            $URL = $Resource.Properties.ipAddress.fqdn
          }
          Write-Scope $URL
          break 
        }
        ## Functions
        "Microsoft.Web/sites/functions$" { Write-Scope $Resource.Properties.hostNames; break }
        ## CosmosDB
        "Microsoft.DocumentDB/databaseAccounts$" {
          Write-Scope $Resource.Properties.documentEndpoint
          Write-Scope $Resource.Properties.tableEndpoint
          Write-Scope $Resource.Properties.gremlinEndpoint
          break
        }
        ## Traffic Manager
        "Microsoft.Network/trafficmanagerprofiles$" { Write-Scope ($Resource.Name + ".trafficmanager.net"); break }
        ## Key Vault
        "Microsoft.KeyVault/vaults$" { Write-Scope $Resource.Properties.vaultUri; break }
        ## DataLake
        "Microsoft.DataLakeStore/accounts$" { Write-Scope $Resource.Properties.endpoint; break }
        ## DataLake Store
        "Microsoft.DataLakeAnalytics/accounts/DataLakeStoreAccounts$" { Write-Scope $Resource.Properties.endpoint; break }
        ## Redis
        "Microsoft.Cache/Redis$" { 
          $port = $Resource.Properties.sslport
          If ($Resource.Properties.EnableNonSslPort) {
            $port = $Resource.Properties.port
          }
          Write-Scope ($Resource.Properties.hostName + ":" + $port)
          break 
        }
        ## Web Apps & App Service Environment
        "Microsoft.Web/sites$" { Write-Scope $Resource.Properties.hostNames; break }
        ## Service Fabric
        "Microsoft.ServiceFabric/clusters$" { Write-Scope $Resource.Properties.clusterEndpoint; break }
        ## Batch
        "Microsoft.Batch/batchAccounts$" { Write-Scope $Resource.Properties.accountEndpoint; break }
        ## Machine Learning
        ## Investigate further their is a swagger def file, maybe some other url service endpoint ?
        ## https://{location}.services.azureml.net/subscriptions/{subscriptionguid}/services/{id}/swagger.json
        ## "Microsoft.MachineLearning/webServices$" { Write-Scope ($Resource.Name + ".services.azureml.net"); break }
        ## Service Bus
        "Microsoft.ServiceBus/namespaces$" { Write-Scope $Resource.Properties.serviceBusEndpoint; break }
        ## Event Hub
        "Microsoft.EventHub/namespaces$" { Write-Scope $Resource.Properties.serviceBusEndpoint; break }
        ## IoT Hub
        "Microsoft.Devices/IotHubs$" { Write-Scope $Resource.Properties.hostName; break }
        ## API Management
        "Microsoft.ApiManagement/service$" { 
          Write-Scope $Resource.Properties.gatewayUrl
          Write-Scope $Resource.Properties.gatewayRegionalUrl
          Write-Scope $Resource.Properties.portalUrl
          Write-Scope $Resource.Properties.managementApiUrl
          break 
        }
        ## Automation
        "Microsoft.Automation/automationAccounts$" { Write-Scope $Resource.Properties.RegistrationUrl; break }
        ## Public IPs
        "Microsoft.Network/publicIPAddresses$" { 
          $URL = $Resource.Properties.ipAddress
          If ($Resource.Properties.dnsSettings.Fqdn -cmatch "cloudapp.azure.com" ) {
            $URL = $Resource.Properties.dnsSettings.Fqdn
          }
          Write-Scope $URL; break 
        }
        ## Search
        "Microsoft.Search/searchServices$" { Write-Scope ($Resource.Name + ".search.windows.net"); break }
        ## Analysis Services
        "Microsoft.AnalysisServices/servers$" { Write-Scope $Resource.Properties.serverFullName; break }
        ## Integration Accounts
        "Microsoft.Logic/integrationAccounts$" { Write-Scope $Resource.Properties.accessEndpoint; break }
        ## CDN
        "Microsoft.Cdn/profiles/endpoints$" { Write-Scope $Resource.Properties.hostName; break }
        ## HD Insight
        "Microsoft.HDInsight/clusters$" { 
          $Resource.Properties.connectivityEndpoints | ForEach-Object {
            Write-Scope ($_.location + ":" + $_.port)
          }; break 
        }
        "$" { Write-Scope ""; break }
      }
    } Catch [Exception] {
        Write-Error "An error occurred: $_"
    }
  } #foreach($Resource in $Resources) 
} #foreach($sub in $subs)

# Time Tracking Finished
$datetimeend = Get-Date
Write-Host "Started on $datetimestart"
Write-Host "Finished on $datetimeend"

# Once done import the data into excel
Import-Csv -Path $scopepath | Export-Csv -Path $outputpath -NoTypeInformation